<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bayesian Portfolio Optimization Tool</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjs@11.5.0/lib/browser/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    <style>
        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --tertiary-color: #1abc9c;
            --background-color: #f8f9fa;
            --card-color: #ffffff;
            --text-color: #333333;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--background-color);
            color: var(--text-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background-color: var(--primary-color);
            color: white;
            padding: 20px 0;
            text-align: center;
            border-radius: 0 0 10px 10px;
            margin-bottom: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            margin: 0;
            font-size: 2.2rem;
        }
        
        .subtitle {
            margin-top: 5px;
            font-size: 1.1rem;
            opacity: 0.9;
        }
        
        .card {
            background-color: var(--card-color);
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
            margin-bottom: 25px;
        }
        
        .card-title {
            color: var(--primary-color);
            margin-top: 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
        }
        
        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            box-sizing: border-box;
            font-family: inherit;
        }
        
        button {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .btn-tertiary {
            background-color: var(--tertiary-color);
        }
        
        .btn-tertiary:hover {
            background-color: #16a085;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        
        .results-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
        }
        
        .chart-container {
            flex: 1;
            min-width: 300px;
            height: 400px;
            position: relative;
        }
        
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .data-table th, .data-table td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        
        .data-table th {
            background-color: #f2f2f2;
        }
        
        .data-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid #ddd;
        }
        
        .tab {
            padding: 10px 20px;
            cursor: pointer;
            background-color: #f1f1f1;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 5px 5px 0 0;
        }
        
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .metrics {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 20px;
        }
        
        .metric-card {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            padding: 15px;
            flex: 1;
            min-width: 200px;
            text-align: center;
        }
        
        .metric-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--secondary-color);
            margin: 10px 0;
        }
        
        .metric-title {
            font-size: 1rem;
            color: #666;
            margin-bottom: 5px;
        }
        
        .asset-inputs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .asset-input {
            flex: 1;
            min-width: 150px;
        }
        
        @media screen and (max-width: 768px) {
            .container {
                padding: 10px;
            }
            
            .results-container {
                flex-direction: column;
            }
            
            .chart-container {
                height: 300px;
            }
            
            .button-group {
                flex-direction: column;
            }
            
            button {
                width: 100%;
            }
        }
        
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--secondary-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 2s linear infinite;
            margin: 20px auto;
            display: none;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #portfolioComparison {
            overflow-x: auto;
        }
        
        .matrix-input {
            width: 100%;
            height: 150px;
            font-family: monospace;
        }
        
        .alert {
            padding: 10px;
            background-color: #f8d7da;
            color: #721c24;
            border-radius: 4px;
            margin-bottom: 15px;
            display: none;
        }
        
        .info-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            background-color: #ccc;
            color: white;
            border-radius: 50%;
            text-align: center;
            line-height: 20px;
            margin-left: 5px;
            cursor: help;
            font-size: 14px;
            font-weight: bold;
        }
        
        .tooltip {
            position: relative;
            display: inline-block;
        }
        
        .tooltip .tooltiptext {
            visibility: hidden;
            width: 250px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 10px;
            position: absolute;
            z-index: 1;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 0.9rem;
            font-weight: normal;
        }
        
        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Bayesian Portfolio Optimization Tool</h1>
            <p class="subtitle">Advanced Risk Management with Bayesian Inference</p>
        </div>
    </header>
    
    <div class="container">
        <div class="card">
            <h2 class="card-title">Portfolio Configuration</h2>
            
            <div class="tabs">
                <div class="tab active" data-tab="manual-input">Manual Input</div>
                <div class="tab" data-tab="sample-data">Sample Data</div>
                <div class="tab" data-tab="file-upload">Upload Data</div>
            </div>
            
            <div class="tab-content active" id="manual-input">
                <div class="form-group">
                    <label for="numAssets">Number of Assets:
                        <span class="tooltip"><span class="info-icon">?</span>
                            <span class="tooltiptext">Enter the number of assets in your portfolio (2-10)</span>
                        </span>
                    </label>
                    <input type="number" id="numAssets" name="numAssets" min="2" max="10" value="3">
                    <button id="generateInputs" class="btn-tertiary" style="margin-top: 10px;">Generate Inputs</button>
                </div>
                
                <div id="assetInputs" style="margin-top: 20px;">
                    <!-- Asset inputs will be generated here -->
                </div>
                
                <div class="form-group" id="returnsMatrixContainer" style="display: none;">
                    <label for="returnsMatrix">Expected Returns Vector (annual %):</label>
                    <textarea id="returnsMatrix" class="matrix-input" placeholder="5.2, 8.3, 4.1"></textarea>
                </div>
                
                <div class="form-group" id="covarianceMatrixContainer" style="display: none;">
                    <label for="covarianceMatrix">Covariance Matrix (annual %):</label>
                    <textarea id="covarianceMatrix" class="matrix-input" placeholder="100, 30, 20
30, 200, 15
20, 15, 80"></textarea>
                </div>
            </div>
            
            <div class="tab-content" id="sample-data">
                <div class="form-group">
                    <label for="sampleDataset">Select Sample Dataset:</label>
                    <select id="sampleDataset">
                        <option value="stocks">US Stocks: Tech, Finance, Healthcare (3 assets)</option>
                        <option value="global">Global Portfolio: US, Europe, Asia, Bonds (4 assets)</option>
                        <option value="sectors">Market Sectors: Tech, Finance, Energy, Consumer, Healthcare (5 assets)</option>
                    </select>
                    <button id="loadSampleData" class="btn-tertiary" style="margin-top: 10px;">Load Data</button>
                </div>
            </div>
            
            <div class="tab-content" id="file-upload">
                <div class="form-group">
                    <label for="csvFile">Upload CSV File:</label>
                    <input type="file" id="csvFile" accept=".csv">
                    <p style="font-size: 0.9rem; color: #666;">CSV format: First column should be dates, following columns should be asset prices.</p>
                    <button id="processFile" class="btn-tertiary" style="margin-top: 10px;">Process File</button>
                </div>
            </div>
            
            <div class="form-group">
                <label for="priorStrength">Prior Strength: 
                    <span class="tooltip"><span class="info-icon">?</span>
                        <span class="tooltiptext">Controls how much the prior influences the final estimate. Higher values give more weight to prior beliefs.</span>
                    </span>
                </label>
                <input type="range" id="priorStrength" name="priorStrength" min="0" max="100" value="50">
                <div style="display: flex; justify-content: space-between;">
                    <span>Weak Prior</span>
                    <span>Strong Prior</span>
                </div>
            </div>
            
            <div class="form-group">
                <label for="riskAversion">Risk Aversion:
                    <span class="tooltip"><span class="info-icon">?</span>
                        <span class="tooltiptext">Higher values prioritize risk reduction over returns. Lower values focus more on maximizing returns.</span>
                    </span>
                </label>
                <input type="range" id="riskAversion" name="riskAversion" min="1" max="10" value="4">
                <div style="display: flex; justify-content: space-between;">
                    <span>Return Focus</span>
                    <span>Risk Focus</span>
                </div>
            </div>
            
            <div class="button-group">
                <button id="optimizeBtn">Run Bayesian Optimization</button>
                <button id="compareBtn" class="btn-tertiary">Compare with Traditional</button>
                <button id="resetBtn" style="background-color: #e74c3c;">Reset</button>
            </div>
        </div>
        
        <div id="alertBox" class="alert"></div>
        
        <div id="resultsSection" style="display: none;">
            <div class="card">
                <h2 class="card-title">Optimization Results</h2>
                
                <div class="metrics">
                    <div class="metric-card">
                        <div class="metric-title">Expected Annual Return</div>
                        <div class="metric-value" id="expectedReturn">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Annual Volatility</div>
                        <div class="metric-value" id="portfolioRisk">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Sharpe Ratio</div>
                        <div class="metric-value" id="sharpeRatio">--</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-title">Posterior Probability</div>
                        <div class="metric-value" id="posteriorProb">--</div>
                    </div>
                </div>
                
                <div class="results-container">
                    <div class="chart-container">
                        <canvas id="allocationChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="efficientFrontierChart"></canvas>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3>Optimal Portfolio Weights</h3>
                    <table class="data-table" id="weightsTable">
                        <thead>
                            <tr>
                                <th>Asset</th>
                                <th>Weight (%)</th>
                                <th>Expected Contribution to Return (%)</th>
                                <th>Contribution to Risk (%)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table content will be generated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
            
            <div class="card" id="portfolioComparison" style="display: none;">
                <h2 class="card-title">Bayesian vs. Traditional Optimization</h2>
                
                <div class="results-container">
                    <div class="chart-container">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <canvas id="stabilityChart"></canvas>
                    </div>
                </div>
                
                <div style="margin-top: 20px;">
                    <h3>Comparison of Methods</h3>
                    <table class="data-table" id="comparisonTable">
                        <thead>
                            <tr>
                                <th>Metric</th>
                                <th>Bayesian Portfolio</th>
                                <th>Traditional (Markowitz)</th>
                                <th>Difference</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Table content will be generated dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="loader" id="loader"></div>
    </div>
    
    <script>
        // Constants and sample data
        const sampleData = {
            stocks: {
                assets: ["Tech Stocks", "Financial Stocks", "Healthcare Stocks"],
                returns: [12.5, 9.2, 7.8],
                covariance: [
                    [256, 64, 40],
                    [64, 144, 36],
                    [40, 36, 100]
                ]
            },
            global: {
                assets: ["US Equities", "European Equities", "Asian Equities", "Bonds"],
                returns: [10.2, 8.5, 11.3, 4.2],
                covariance: [
                    [196, 84, 90, 12],
                    [84, 169, 78, 14],
                    [90, 78, 225, 8],
                    [12, 14, 8, 36]
                ]
            },
            sectors: {
                assets: ["Technology", "Financial", "Energy", "Consumer", "Healthcare"],
                returns: [14.3, 9.6, 7.2, 8.4, 10.8],
                covariance: [
                    [225, 72, 45, 54, 63],
                    [72, 144, 36, 32, 40],
                    [45, 36, 169, 27, 36],
                    [54, 32, 27, 100, 45],
                    [63, 40, 36, 45, 121]
                ]
            }
        };
        
        // DOM Elements
        const numAssetsInput = document.getElementById('numAssets');
        const generateInputsBtn = document.getElementById('generateInputs');
        const assetInputsDiv = document.getElementById('assetInputs');
        const returnsMatrixContainer = document.getElementById('returnsMatrixContainer');
        const returnsMatrixInput = document.getElementById('returnsMatrix');
        const covarianceMatrixContainer = document.getElementById('covarianceMatrixContainer');
        const covarianceMatrixInput = document.getElementById('covarianceMatrix');
        const optimizeBtn = document.getElementById('optimizeBtn');
        const compareBtn = document.getElementById('compareBtn');
        const resetBtn = document.getElementById('resetBtn');
        const resultsSection = document.getElementById('resultsSection');
        const loadSampleDataBtn = document.getElementById('loadSampleData');
        const processFileBtn = document.getElementById('processFile');
        const sampleDatasetSelect = document.getElementById('sampleDataset');
        const csvFileInput = document.getElementById('csvFile');
        const loader = document.getElementById('loader');
        const alertBox = document.getElementById('alertBox');
        const portfolioComparison = document.getElementById('portfolioComparison');
        
        // Chart objects
        let allocationChart = null;
        let efficientFrontierChart = null;
        let comparisonChart = null;
        let stabilityChart = null;
        
        // Initialize tabs
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(tab.dataset.tab).classList.add('active');
            });
        });
        
        // Generate asset inputs based on number of assets
        generateInputsBtn.addEventListener('click', () => {
            const numAssets = parseInt(numAssetsInput.value);
            
            if (numAssets < 2 || numAssets > 10) {
                showAlert('Please enter a number between 2 and 10');
                return;
            }
            
            assetInputsDiv.innerHTML = '';
            let assetInputsHTML = '<div class="asset-inputs">';
            
            for (let i = 0; i < numAssets; i++) {
                assetInputsHTML += `
                <div class="asset-input">
                    <div class="form-group">
                        <label for="asset${i}">Asset ${i+1} Name:</label>
                        <input type="text" id="asset${i}" value="Asset ${i+1}">
                    </div>
                </div>`;
            }
            
            assetInputsHTML += '</div>';
            assetInputsDiv.innerHTML = assetInputsHTML;
            
            // Generate default returns vector
            let returnsStr = '';
            for (let i = 0; i < numAssets; i++) {
                returnsStr += (Math.random() * 10 + 5).toFixed(2);
                if (i < numAssets - 1) returnsStr += ', ';
            }
            returnsMatrixInput.value = returnsStr;
            
            // Generate default covariance matrix
            let covarianceStr = '';
            const defaultCov = Array(numAssets).fill(0).map(() => Array(numAssets).fill(0));
            
            for (let i = 0; i < numAssets; i++) {
                defaultCov[i][i] = Math.floor(Math.random() * 150) + 50; // Diagonal elements (variance)
                
                for (let j = 0; j < i; j++) {
                    // Generate correlation between -0.2 and 0.8, more biased toward positive correlation
                    const correlation = Math.random() * 0.6 + 0.2;
                    defaultCov[i][j] = Math.floor(correlation * Math.sqrt(defaultCov[i][i] * defaultCov[j][j]));
                    defaultCov[j][i] = defaultCov[i][j]; // Symmetric matrix
                }
            }
            
            for (let i = 0; i < numAssets; i++) {
                for (let j = 0; j < numAssets; j++) {
                    covarianceStr += defaultCov[i][j];
                    if (j < numAssets - 1) covarianceStr += ', ';
                }
                if (i < numAssets - 1) covarianceStr += '\n';
            }
            
            covarianceMatrixInput.value = covarianceStr;
            
            returnsMatrixContainer.style.display = 'block';
            covarianceMatrixContainer.style.display = 'block';
        });
        
        // Load sample data
        loadSampleDataBtn.addEventListener('click', () => {
            const selectedDataset = sampleDatasetSelect.value;
            const data = sampleData[selectedDataset];
            
            // Update UI to reflect sample data
            numAssetsInput.value = data.assets.length;
            
            // Generate asset input fields
            assetInputsDiv.innerHTML = '';
            let assetInputsHTML = '<div class="asset-inputs">';
            
            for (let i = 0; i < data.assets.length; i++) {
                assetInputsHTML += `
                <div class="asset-input">
                    <div class="form-group">
                        <label for="asset${i}">Asset ${i+1} Name:</label>
                        <input type="text" id="asset${i}" value="${data.assets[i]}">
                    </div>
                </div>`;
            }
            
            assetInputsHTML += '</div>';
            assetInputsDiv.innerHTML = assetInputsHTML;
            
            // Set returns vector
            returnsMatrixInput.value = data.returns.join(', ');
            
            // Set covariance matrix
            let covarianceStr = '';
            for (let i = 0; i < data.covariance.length; i++) {
                covarianceStr += data.covariance[i].join(', ');
                if (i < data.covariance.length - 1) covarianceStr += '\n';
            }
            covarianceMatrixInput.value = covarianceStr;
            
            returnsMatrixContainer.style.display = 'block';
            covarianceMatrixContainer.style.display = 'block';
            
            // Switch to manual input tab to show the data
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            document.querySelector('.tab[data-tab="manual-input"]').classList.add('active');
            document.getElementById('manual-input').classList.add('active');
        });
        
        // Process CSV file
        processFileBtn.addEventListener('click', () => {
            const file = csvFileInput.files[0];
            if (!file) {
                showAlert('Please select a file to upload');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const contents = e.target.result;
                    const rows = contents.split('\n');
                    const header = rows[0].split(',');
                    
                    // Extract asset names (header except first column which is date)
                    const assetNames = header.slice(1).map(name => name.trim());
                    const numAssets = assetNames.length;
                    
                    if (numAssets < 2) {
                        showAlert('CSV must contain at least 2 assets (columns)');
                        return;
                    }
                    
                    // Extract price data
                    const priceData = [];
                    for (let i = 1; i < rows.length; i++) {
                        if (rows[i].trim() === '') continue;
                        
                        const rowData = rows[i].split(',');
                        const prices = rowData.slice(1).map(price => parseFloat(price.trim()));
                        
                        if (prices.some(isNaN)) continue;
                        priceData.push(prices);
                    }
                    
                    if (priceData.length < 30) {
                        showAlert('Not enough data rows. At least 30 price points needed.');
                        return;
                    }
                    
                    // Calculate returns
                    const returns = [];
                    for (let i = 1; i < priceData.length; i++) {
                        const dailyReturns = [];
                        for (let j = 0; j < numAssets; j++) {
                            const dailyReturn = (priceData[i][j] / priceData[i-1][j]) - 1;
                            dailyReturns.push(dailyReturn);
                        }
                        returns.push(dailyReturns);
                    }
                    
                    // Calculate average returns (annualized)
                    const avgReturns = [];
                    for (let j = 0; j < numAssets; j++) {
                        let sum = 0;
                        for (let i = 0; i < returns.length; i++) {
                            sum += returns[i][j];
                        }
                        // Annualize (assuming daily data with 252 trading days)
                        avgReturns.push(((sum / returns.length) * 252 * 100).toFixed(2));
                    }
                    
                    // Calculate covariance matrix (annualized)
                    const covMatrix = Array(numAssets).fill(0).map(() => Array(numAssets).fill(0));
                    
                    for (let i = 0; i < numAssets; i++) {
                        for (let j = 0; j < numAssets; j++) {
                            let covariance = 0;
                            
                            for (let k = 0; k < returns.length; k++) {
                                const returnI = returns[k][i];
                                const returnJ = returns[k][j];
                                const avgReturnI = avgReturns[i] / (252 * 100);
                                const avgReturnJ = avgReturns[j] / (252 * 100);
                                
                                covariance += (returnI - avgReturnI) * (returnJ - avgReturnJ);
                            }
                            
                            covariance = covariance / (returns.length - 1);
                            // Annualize variance-covariance (multiply by 252 trading days)
                            covMatrix[i][j] = Math.round(covariance * 252 * 10000);  // Scaled for better display
                        }
                    }
                    
                    // Update UI
                    numAssetsInput.value = numAssets;
                    
                    // Generate asset input fields
                    assetInputsDiv.innerHTML = '';
                    let assetInputsHTML = '<div class="asset-inputs">';
                    
                    for (let i = 0; i < numAssets; i++) {
                        assetInputsHTML += `
                        <div class="asset-input">
                            <div class="form-group">
                                <label for="asset${i}">Asset ${i+1} Name:</label>
                                <input type="text" id="asset${i}" value="${assetNames[i]}">
                            </div>
                        </div>`;
                    }
                    
                    assetInputsHTML += '</div>';
                    assetInputsDiv.innerHTML = assetInputsHTML;
                    
                    // Set returns vector
                    returnsMatrixInput.value = avgReturns.join(', ');
                    
                    // Set covariance matrix
                    let covarianceStr = '';
                    for (let i = 0; i < covMatrix.length; i++) {
                        covarianceStr += covMatrix[i].join(', ');
                        if (i < covMatrix.length - 1) covarianceStr += '\n';
                    }
                    covarianceMatrixInput.value = covarianceStr;
                    
                    returnsMatrixContainer.style.display = 'block';
                    covarianceMatrixContainer.style.display = 'block';
                    
                    // Switch to manual input tab to show the data
                    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
                    document.querySelector('.tab[data-tab="manual-input"]').classList.add('active');
                    document.getElementById('manual-input').classList.add('active');
                    
                    showAlert('Data successfully processed from CSV file', 'success');
                    
                } catch (error) {
                    console.error(error);
                    showAlert('Error processing CSV file. Please check the format.');
                }
            };
            reader.readAsText(file);
        });
        
        // Optimize portfolio
        optimizeBtn.addEventListener('click', () => {
            try {
                // Show loader
                loader.style.display = 'block';
                
                // Get input data
                const assets = [];
                const numAssets = parseInt(numAssetsInput.value);
                
                for (let i = 0; i < numAssets; i++) {
                    const assetInput = document.getElementById(`asset${i}`);
                    if (assetInput) {
                        assets.push(assetInput.value);
                    } else {
                        assets.push(`Asset ${i+1}`);
                    }
                }
                
                // Parse returns
                const returnsStr = returnsMatrixInput.value;
                const returns = returnsStr.split(',').map(r => parseFloat(r.trim()));
                
                if (returns.length !== numAssets || returns.some(isNaN)) {
                    showAlert('Invalid returns vector format');
                    loader.style.display = 'none';
                    return;
                }
                
                // Parse covariance matrix
                const covarianceStr = covarianceMatrixInput.value;
                const covRows = covarianceStr.split('\n');
                const covariance = [];
                
                for (let i = 0; i < covRows.length; i++) {
                    const row = covRows[i].split(',').map(c => parseFloat(c.trim()));
                    if (row.length !== numAssets || row.some(isNaN)) {
                        showAlert('Invalid covariance matrix format');
                        loader.style.display = 'none';
                        return;
                    }
                    covariance.push(row);
                }
                
                if (covariance.length !== numAssets) {
                    showAlert('Covariance matrix dimensions do not match number of assets');
                    loader.style.display = 'none';
                    return;
                }
                
                // Get prior strength and risk aversion parameters
                const priorStrength = document.getElementById('priorStrength').value / 100;
                const riskAversion = document.getElementById('riskAversion').value;
                
                // Simulate delay for calculation (in real app, this would be actual calculation time)
                setTimeout(() => {
                    // Run Bayesian optimization
                    const bayesianResult = runBayesianOptimization(assets, returns, covariance, priorStrength, riskAversion);
                    
                    // Update UI with results
                    updateResults(bayesianResult);
                    
                    // Hide loader
                    loader.style.display = 'none';
                    
                    // Show results section
                    resultsSection.style.display = 'block';
                    
                    // Hide comparison section
                    portfolioComparison.style.display = 'none';
                    
                    // Scroll to results
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                }, 1500);
                
            } catch (error) {
                console.error(error);
                showAlert('Error in optimization: ' + error.message);
                loader.style.display = 'none';
            }
        });
        
        // Compare with traditional portfolio optimization
        compareBtn.addEventListener('click', () => {
            try {
                // Show loader
                loader.style.display = 'block';
                
                // Get input data
                const assets = [];
                const numAssets = parseInt(numAssetsInput.value);
                
                for (let i = 0; i < numAssets; i++) {
                    const assetInput = document.getElementById(`asset${i}`);
                    if (assetInput) {
                        assets.push(assetInput.value);
                    } else {
                        assets.push(`Asset ${i+1}`);
                    }
                }
                
                // Parse returns
                const returnsStr = returnsMatrixInput.value;
                const returns = returnsStr.split(',').map(r => parseFloat(r.trim()));
                
                if (returns.length !== numAssets || returns.some(isNaN)) {
                    showAlert('Invalid returns vector format');
                    loader.style.display = 'none';
                    return;
                }
                
                // Parse covariance matrix
                const covarianceStr = covarianceMatrixInput.value;
                const covRows = covarianceStr.split('\n');
                const covariance = [];
                
                for (let i = 0; i < covRows.length; i++) {
                    const row = covRows[i].split(',').map(c => parseFloat(c.trim()));
                    if (row.length !== numAssets || row.some(isNaN)) {
                        showAlert('Invalid covariance matrix format');
                        loader.style.display = 'none';
                        return;
                    }
                    covariance.push(row);
                }
                
                if (covariance.length !== numAssets) {
                    showAlert('Covariance matrix dimensions do not match number of assets');
                    loader.style.display = 'none';
                    return;
                }
                
                // Get prior strength and risk aversion parameters
                const priorStrength = document.getElementById('priorStrength').value / 100;
                const riskAversion = document.getElementById('riskAversion').value;
                
                // Simulate delay for calculation (in real app, this would be actual calculation time)
                setTimeout(() => {
                    // Run Bayesian optimization
                    const bayesianResult = runBayesianOptimization(assets, returns, covariance, priorStrength, riskAversion);
                    
                    // Run traditional optimization
                    const traditionalResult = runTraditionalOptimization(assets, returns, covariance, riskAversion);
                    
                    // Update UI with results
                    updateResults(bayesianResult);
                    updateComparisonResults(bayesianResult, traditionalResult);
                    
                    // Hide loader
                    loader.style.display = 'none';
                    
                    // Show results section and comparison section
                    resultsSection.style.display = 'block';
                    portfolioComparison.style.display = 'block';
                    
                    // Scroll to results
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                }, 1500);
                
            } catch (error) {
                console.error(error);
                showAlert('Error in comparison: ' + error.message);
                loader.style.display = 'none';
            }
        });
        
        // Reset form
        resetBtn.addEventListener('click', () => {
            // Reset form inputs
            numAssetsInput.value = 3;
            assetInputsDiv.innerHTML = '';
            returnsMatrixInput.value = '';
            covarianceMatrixInput.value = '';
            document.getElementById('priorStrength').value = 50;
            document.getElementById('riskAversion').value = 4;
            
            // Reset file input
            csvFileInput.value = '';
            
            // Hide containers
            returnsMatrixContainer.style.display = 'none';
            covarianceMatrixContainer.style.display = 'none';
            
            // Hide results
            resultsSection.style.display = 'none';
            portfolioComparison.style.display = 'none';
            
            // Reset tab to manual input
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            document.querySelector('.tab[data-tab="manual-input"]').classList.add('active');
            document.getElementById('manual-input').classList.add('active');
        });
        
        // Utility function to show alerts
        function showAlert(message, type = 'error') {
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            
            if (type === 'error') {
                alertBox.style.backgroundColor = '#f8d7da';
                alertBox.style.color = '#721c24';
            } else if (type === 'success') {
                alertBox.style.backgroundColor = '#d4edda';
                alertBox.style.color = '#155724';
            } else if (type === 'warning') {
                alertBox.style.backgroundColor = '#fff3cd';
                alertBox.style.color = '#856404';
            }
            
            setTimeout(() => {
                alertBox.style.display = 'none';
            }, 5000);
        }
        
        // Bayesian Portfolio Optimization Calculation
        function runBayesianOptimization(assets, returns, covariance, priorStrength, riskAversion) {
            const numAssets = assets.length;
            
            // Prior parameters (reasonable values for diversified portfolios)
            // Equal weight prior with moderate returns and risk
            const priorReturns = Array(numAssets).fill(0).map(() => 8 + Math.random() * 2); // Prior returns around 8-10%
            const priorWeights = Array(numAssets).fill(1/numAssets); // Equal weights prior
            
            // Apply Bayesian adjustment to returns based on prior strength
            const posteriorReturns = [];
            for (let i = 0; i < numAssets; i++) {
                posteriorReturns.push(returns[i] * (1 - priorStrength) + priorReturns[i] * priorStrength);
            }
            
            // Shrink covariance matrix toward diagonal (reducing extreme correlations)
            const posteriorCovariance = [];
            for (let i = 0; i < numAssets; i++) {
                posteriorCovariance[i] = [];
                for (let j = 0; j < numAssets; j++) {
                    if (i === j) {
                        // Keep variance on diagonal
                        posteriorCovariance[i][j] = covariance[i][j];
                    } else {
                        // Shrink off-diagonal covariances
                        posteriorCovariance[i][j] = covariance[i][j] * (1 - priorStrength * 0.5);
                    }
                }
            }
            
            // Calculate mean-variance optimization
            const result = optimizePortfolio(posteriorReturns, posteriorCovariance, riskAversion);
            
            // Calculate metrics for the optimized portfolio
            const weights = result.weights;
            const expectedReturn = weights.reduce((sum, w, i) => sum + w * posteriorReturns[i], 0);
            
            let portfolioRisk = 0;
            for (let i = 0; i < numAssets; i++) {
                for (let j = 0; j < numAssets; j++) {
                    portfolioRisk += weights[i] * weights[j] * posteriorCovariance[i][j];
                }
            }
            portfolioRisk = Math.sqrt(portfolioRisk);
            
            const riskFreeRate = 2.0; // Assumed risk-free rate (%)
            const sharpeRatio = (expectedReturn - riskFreeRate) / portfolioRisk;
            
            // Calculate contribution to risk and return for each asset
            const contributionToReturn = weights.map((w, i) => w * posteriorReturns[i]);
            const contributionToRisk = [];
            
            for (let i = 0; i < numAssets; i++) {
                let contribution = 0;
                for (let j = 0; j < numAssets; j++) {
                    contribution += weights[j] * posteriorCovariance[i][j];
                }
                contributionToRisk.push(weights[i] * contribution / portfolioRisk);
            }
            
            // Generate efficient frontier points for visualization
            const frontierPoints = generateEfficientFrontier(posteriorReturns, posteriorCovariance);
            
            // Create stability analysis (sensitivity to input parameters)
            const stabilityAnalysis = analyzeStability(posteriorReturns, posteriorCovariance, weights, riskAversion);
            
            // Calculate posterior probability (simplified metric between 0-1)
            const posteriorProb = 0.75 + 0.25 * (1 - Math.exp(-stabilityAnalysis.averageStability)); 
            
            return {
                assets,
                weights,
                expectedReturn,
                portfolioRisk,
                sharpeRatio,
                posteriorProb,
                contributionToReturn,
                contributionToRisk,
                posteriorReturns,
                posteriorCovariance,
                frontierPoints,
                stabilityAnalysis
            };
        }
        
        // Traditional Portfolio Optimization Calculation
        function runTraditionalOptimization(assets, returns, covariance, riskAversion) {
            const numAssets = assets.length;
            
            // Calculate mean-variance optimization
            const result = optimizePortfolio(returns, covariance, riskAversion);
            
            // Calculate metrics for the optimized portfolio
            const weights = result.weights;
            const expectedReturn = weights.reduce((sum, w, i) => sum + w * returns[i], 0);
            
            let portfolioRisk = 0;
            for (let i = 0; i < numAssets; i++) {
                for (let j = 0; j < numAssets; j++) {
                    portfolioRisk += weights[i] * weights[j] * covariance[i][j];
                }
            }
            portfolioRisk = Math.sqrt(portfolioRisk);
            
            const riskFreeRate = 2.0; // Assumed risk-free rate (%)
            const sharpeRatio = (expectedReturn - riskFreeRate) / portfolioRisk;
            
            // Calculate contribution to risk and return for each asset
            const contributionToReturn = weights.map((w, i) => w * returns[i]);
            const contributionToRisk = [];
            
            for (let i = 0; i < numAssets; i++) {
                let contribution = 0;
                for (let j = 0; j < numAssets; j++) {
                    contribution += weights[j] * covariance[i][j];
                }
                contributionToRisk.push(weights[i] * contribution / portfolioRisk);
            }
            
            // Generate efficient frontier points for visualization
            const frontierPoints = generateEfficientFrontier(returns, covariance);
            
            // Create stability analysis (sensitivity to input parameters)
            const stabilityAnalysis = analyzeStability(returns, covariance, weights, riskAversion);
            
            return {
                assets,
                weights,
                expectedReturn,
                portfolioRisk,
                sharpeRatio,
                contributionToReturn,
                contributionToRisk,
                frontierPoints,
                stabilityAnalysis
            };
        }
        
        // Mean-Variance Optimization Algorithm
        function optimizePortfolio(returns, covariance, riskAversion) {
            const numAssets = returns.length;
            
            // Simple quadratic programming solver for mean-variance optimization
            // We solve: max(w'μ - λ/2 * w'Σw) subject to sum(w) = 1, w ≥ 0
            // where w is the weight vector, μ is the returns vector, Σ is the covariance matrix, λ is risk aversion
            
            // For simplicity, we'll use a numerical optimization approach
            // In a real application, you'd use a proper QP solver
            
            // Convert inputs to appropriate format
            const mu = returns.map(r => r / 100); // Convert percentage to decimal
            const sigma = [];
            for (let i = 0; i < numAssets; i++) {
                sigma[i] = [];
                for (let j = 0; j < numAssets; j++) {
                    sigma[i][j] = covariance[i][j] / 10000; // Convert to decimal (assuming input is in % squared)
                }
            }
            
            // Initial guess: equal weights
            let weights = Array(numAssets).fill(1/numAssets);
            
            // Define objective function: maximize utility (return - risk penalty)
            const objective = (w) => {
                let portReturn = 0;
                for (let i = 0; i < numAssets; i++) {
                    portReturn += w[i] * mu[i];
                }
                
                let portRisk = 0;
                for (let i = 0; i < numAssets; i++) {
                    for (let j = 0; j < numAssets; j++) {
                        portRisk += w[i] * w[j] * sigma[i][j];
                    }
                }
                
                // Negative because we're maximizing
                return -(portReturn - (riskAversion/2) * portRisk);
            };
            
            // Simple gradient descent optimization (in practice, use a better algorithm)
            const learningRate = 0.01;
            const iterations = 2000;
            
            for (let iter = 0; iter < iterations; iter++) {
                // Calculate gradient numerically (finite difference)
                const gradient = [];
                const h = 0.0001; // Small perturbation
                
                for (let i = 0; i < numAssets; i++) {
                    const perturbed = [...weights];
                    perturbed[i] += h;
                    
                    // Normalize perturbed weights
                    const sum = perturbed.reduce((a, b) => a + b, 0);
                    for (let j = 0; j < numAssets; j++) {
                        perturbed[j] /= sum;
                    }
                    
                    // Calculate finite difference
                    const f1 = objective(weights);
                    const f2 = objective(perturbed);
                    gradient[i] = (f2 - f1) / h;
                }
                
                // Update weights
                for (let i = 0; i < numAssets; i++) {
                    weights[i] -= learningRate * gradient[i];
                    // Ensure non-negative weights
                    weights[i] = Math.max(0, weights[i]);
                }
                
                // Normalize weights to sum to 1
                const sum = weights.reduce((a, b) => a + b, 0);
                for (let i = 0; i < numAssets; i++) {
                    weights[i] /= sum;
                }
            }
            
            return { weights };
        }
        
        // Generate points on the efficient frontier
        function generateEfficientFrontier(returns, covariance) {
            const points = [];
            const numPoints = 20;
            
            // Use various risk aversion levels to trace the frontier
            for (let i = 0; i < numPoints; i++) {
                const riskAversion = 1 + i * 1.5; // Range from 1 to 30
                
                const result = optimizePortfolio(returns, covariance, riskAversion);
                const weights = result.weights;
                
                // Calculate expected return for these weights
                const expectedReturn = weights.reduce((sum, w, i) => sum + w * returns[i], 0);
                
                // Calculate portfolio risk for these weights
                let portfolioRisk = 0;
                for (let i = 0; i < returns.length; i++) {
                    for (let j = 0; j < returns.length; j++) {
                        portfolioRisk += weights[i] * weights[j] * covariance[i][j];
                    }
                }
                portfolioRisk = Math.sqrt(portfolioRisk);
                
                points.push({ risk: portfolioRisk, return: expectedReturn });
            }
            
            // Sort points by risk
            points.sort((a, b) => a.risk - b.risk);
            
            return points;
        }
        
        // Analyze portfolio stability
        function analyzeStability(returns, covariance, weights, riskAversion) {
            const numAssets = returns.length;
            const perturbationSize = 0.1; // 10% perturbation
            const numIterations = 10;
            
            const weightStabilities = Array(numAssets).fill(0);
            const returnPerturbations = [];
            const riskPerturbations = [];
            
            // Perturb each input parameter and recalculate
            for (let iter = 0; iter < numIterations; iter++) {
                // Perturb returns
                const perturbedReturns = returns.map(r => r * (1 + (Math.random() * 2 - 1) * perturbationSize));
                
                // Perturb covariance
                const perturbedCovariance = [];
                for (let i = 0; i < numAssets; i++) {
                    perturbedCovariance[i] = [];
                    for (let j = 0; j < numAssets; j++) {
                        // Keep positive semi-definite property by being more careful with perturbations
                        if (i === j) {
                            // Variance can't be negative
                            perturbedCovariance[i][j] = covariance[i][j] * (1 + Math.random() * perturbationSize);
                        } else {
                            // Keep correlation in [-1, 1]
                            const stdDev_i = Math.sqrt(covariance[i][i]);
                            const stdDev_j = Math.sqrt(covariance[j][j]);
                            const corr = covariance[i][j] / (stdDev_i * stdDev_j);
                            
                            const newCorr = Math.max(-0.99, Math.min(0.99, corr * (1 + (Math.random() * 2 - 1) * perturbationSize * 0.5)));
                            perturbedCovariance[i][j] = newCorr * Math.sqrt(perturbedCovariance[i][i] * perturbedCovariance[j][j]);
                        }
                    }
                }
                
                // Re-optimize
                const result = optimizePortfolio(perturbedReturns, perturbedCovariance, riskAversion);
                const newWeights = result.weights;
                
                // Calculate weight stability
                for (let i = 0; i < numAssets; i++) {
                    weightStabilities[i] += Math.abs(weights[i] - newWeights[i]);
                }
                
                // Calculate portfolio metrics with perturbed inputs
                const expectedReturn = newWeights.reduce((sum, w, i) => sum + w * perturbedReturns[i], 0);
                
                let portfolioRisk = 0;
                for (let i = 0; i < numAssets; i++) {
                    for (let j = 0; j < numAssets; j++) {
                        portfolioRisk += newWeights[i] * newWeights[j] * perturbedCovariance[i][j];
                    }
                }
                portfolioRisk = Math.sqrt(portfolioRisk);
                
                returnPerturbations.push(expectedReturn);
                riskPerturbations.push(portfolioRisk);
            }
            
            // Normalize weight stability scores (lower is better)
            for (let i = 0; i < numAssets; i++) {
                weightStabilities[i] = 1 - (weightStabilities[i] / numIterations); // Convert to 0-1 scale (1 is most stable)
            }
            
            // Calculate average weight stability
            const averageStability = weightStabilities.reduce((a, b) => a + b, 0) / numAssets;
            
            // Calculate return and risk stability (standard deviation of results)
            const avgReturn = returnPerturbations.reduce((a, b) => a + b, 0) / numIterations;
            const returnDeviation = Math.sqrt(returnPerturbations.reduce((sum, r) => sum + Math.pow(r - avgReturn, 2), 0) / numIterations);
            
            const avgRisk = riskPerturbations.reduce((a, b) => a + b, 0) / numIterations;
            const riskDeviation = Math.sqrt(riskPerturbations.reduce((sum, r) => sum + Math.pow(r - avgRisk, 2), 0) / numIterations);
            
            return {
                weightStabilities,
                averageStability,
                returnPerturbations,
                riskPerturbations,
                returnDeviation,
                riskDeviation
            };
        }
        
        // Update UI with optimization results
        function updateResults(result) {
            // Format percentages
            const expectedReturn = result.expectedReturn.toFixed(2) + '%';
            const portfolioRisk = result.portfolioRisk.toFixed(2) + '%';
            const sharpeRatio = result.sharpeRatio.toFixed(2);
            const posteriorProb = (result.posteriorProb * 100).toFixed(1) + '%';
            
            // Update metrics
            document.getElementById('expectedReturn').textContent = expectedReturn;
            document.getElementById('portfolioRisk').textContent = portfolioRisk;
            document.getElementById('sharpeRatio').textContent = sharpeRatio;
            document.getElementById('posteriorProb').textContent = posteriorProb;
            
            // Update weights table
            const tableBody = document.getElementById('weightsTable').querySelector('tbody');
            tableBody.innerHTML = '';
            
            for (let i = 0; i < result.assets.length; i++) {
                const row = document.createElement('tr');
                
                // Format with 2 decimal places and percentage
                const weightPct = (result.weights[i] * 100).toFixed(2) + '%';
                const returnContribPct = result.contributionToReturn[i].toFixed(2) + '%';
                const riskContribPct = result.contributionToRisk[i].toFixed(2) + '%';
                
                row.innerHTML = `
                    <td>${result.assets[i]}</td>
                    <td>${weightPct}</td>
                    <td>${returnContribPct}</td>
                    <td>${riskContribPct}</td>
                `;
                
                tableBody.appendChild(row);
            }
            
            // Update allocation chart
            const ctx1 = document.getElementById('allocationChart').getContext('2d');
            
            if (allocationChart) {
                allocationChart.destroy();
            }
            
            allocationChart = new Chart(ctx1, {
                type: 'pie',
                data: {
                    labels: result.assets,
                    datasets: [{
                        data: result.weights.map(w => w * 100),
                        backgroundColor: [
                            '#3498db', '#2ecc71', '#e74c3c', '#f1c40f', '#9b59b6',
                            '#1abc9c', '#e67e22', '#34495e', '#d35400', '#c0392b'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portfolio Allocation',
                            font: {
                                size: 16
                            }
                        },
                        legend: {
                            position: 'right'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw.toFixed(2) + '%';
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    }
                }
            });
            
            // Update efficient frontier chart
            const ctx2 = document.getElementById('efficientFrontierChart').getContext('2d');
            
            if (efficientFrontierChart) {
                efficientFrontierChart.destroy();
            }
            
            // Prepare data for efficient frontier
            const frontierRisks = result.frontierPoints.map(p => p.risk);
            const frontierReturns = result.frontierPoints.map(p => p.return);
            
            efficientFrontierChart = new Chart(ctx2, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Efficient Frontier',
                            data: result.frontierPoints.map(p => ({ x: p.risk, y: p.return })),
                            showLine: true,
                            borderColor: '#3498db',
                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
                            fill: false,
                            pointRadius: 3,
                            pointBackgroundColor: '#3498db'
                        },
                        {
                            label: 'Optimal Portfolio',
                            data: [{ x: result.portfolioRisk, y: result.expectedReturn }],
                            pointRadius: 8,
                            pointBackgroundColor: '#e74c3c'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Efficient Frontier',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataset = context.dataset.label;
                                    const risk = context.parsed.x.toFixed(2) + '%';
                                    const ret = context.parsed.y.toFixed(2) + '%';
                                    return `${dataset}: Risk ${risk}, Return ${ret}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Portfolio Risk (Volatility)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Expected Return'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Update UI with comparison results
        function updateComparisonResults(bayesianResult, traditionalResult) {
            // Update comparison table
            const tableBody = document.getElementById('comparisonTable').querySelector('tbody');
            tableBody.innerHTML = '';
            
            // Calculate differences
            const returnDiff = bayesianResult.expectedReturn - traditionalResult.expectedReturn;
            const riskDiff = bayesianResult.portfolioRisk - traditionalResult.portfolioRisk;
            const sharpeDiff = bayesianResult.sharpeRatio - traditionalResult.sharpeRatio;
            const stabilityDiff = bayesianResult.stabilityAnalysis.averageStability - traditionalResult.stabilityAnalysis.averageStability;
            
            // Format with plus sign for positive differences
            const formatDiff = (diff) => {
                return (diff >= 0 ? '+' : '') + diff.toFixed(2);
            };
            
            // Add rows to table
            addComparisonRow('Expected Return', bayesianResult.expectedReturn.toFixed(2) + '%', traditionalResult.expectedReturn.toFixed(2) + '%', formatDiff(returnDiff) + '%');
            addComparisonRow('Portfolio Risk', bayesianResult.portfolioRisk.toFixed(2) + '%', traditionalResult.portfolioRisk.toFixed(2) + '%', formatDiff(riskDiff) + '%');
            addComparisonRow('Sharpe Ratio', bayesianResult.sharpeRatio.toFixed(2), traditionalResult.sharpeRatio.toFixed(2), formatDiff(sharpeDiff));
            addComparisonRow('Stability Score', (bayesianResult.stabilityAnalysis.averageStability * 100).toFixed(1) + '%', (traditionalResult.stabilityAnalysis.averageStability * 100).toFixed(1) + '%', formatDiff(stabilityDiff * 100) + '%');
            
            // Helper function for adding rows with colored differences
            function addComparisonRow(metric, bayesianValue, traditionalValue, diffValue) {
                const row = document.createElement('tr');
                
                // Color code differences (green for better, red for worse)
                let diffClass = '';
                let firstIsBetter = false;
                
                if (metric === 'Portfolio Risk') {
                    // For risk, lower is better
                    firstIsBetter = diffValue.startsWith('-');
                } else {
                    // For everything else, higher is better
                    firstIsBetter = !diffValue.startsWith('-');
                }
                
                diffClass = firstIsBetter ? 'style="color: #2ecc71; font-weight: bold;"' : 'style="color: #e74c3c;"';
                
                row.innerHTML = `
                    <td>${metric}</td>
                    <td>${bayesianValue}</td>
                    <td>${traditionalValue}</td>
                    <td ${diffClass}>${diffValue}</td>
                `;
                
                tableBody.appendChild(row);
            }
            
            // Update comparison chart
            const ctx3 = document.getElementById('comparisonChart').getContext('2d');
            
            if (comparisonChart) {
                comparisonChart.destroy();
            }
            
            comparisonChart = new Chart(ctx3, {
                type: 'bar',
                data: {
                    labels: bayesianResult.assets,
                    datasets: [
                        {
                            label: 'Bayesian Weights',
                            data: bayesianResult.weights.map(w => w * 100),
                            backgroundColor: 'rgba(52, 152, 219, 0.7)'
                        },
                        {
                            label: 'Traditional Weights',
                            data: traditionalResult.weights.map(w => w * 100),
                            backgroundColor: 'rgba(231, 76, 60, 0.7)'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Portfolio Weights Comparison',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.dataset.label || '';
                                    const value = context.raw.toFixed(2) + '%';
                                    return `${label}: ${value}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            title: {
                                display: true,
                                text: 'Weight (%)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Update stability chart
            const ctx4 = document.getElementById('stabilityChart').getContext('2d');
            
            if (stabilityChart) {
                stabilityChart.destroy();
            }
            
            // Calculate variations in returns and risks from perturbation analysis
            const bayesianReturnRange = [
                Math.min(...bayesianResult.stabilityAnalysis.returnPerturbations),
                Math.max(...bayesianResult.stabilityAnalysis.returnPerturbations)
            ];
            
            const bayesianRiskRange = [
                Math.min(...bayesianResult.stabilityAnalysis.riskPerturbations),
                Math.max(...bayesianResult.stabilityAnalysis.riskPerturbations)
            ];
            
            const traditionalReturnRange = [
                Math.min(...traditionalResult.stabilityAnalysis.returnPerturbations),
                Math.max(...traditionalResult.stabilityAnalysis.returnPerturbations)
            ];
            
            const traditionalRiskRange = [
                Math.min(...traditionalResult.stabilityAnalysis.riskPerturbations),
                Math.max(...traditionalResult.stabilityAnalysis.riskPerturbations)
            ];
            
            stabilityChart = new Chart(ctx4, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Bayesian Portfolio',
                            data: [{
                                x: bayesianResult.portfolioRisk,
                                y: bayesianResult.expectedReturn
                            }],
                            backgroundColor: 'rgba(52, 152, 219, 1)',
                            pointRadius: 8
                        },
                        {
                            label: 'Traditional Portfolio',
                            data: [{
                                x: traditionalResult.portfolioRisk,
                                y: traditionalResult.expectedReturn
                            }],
                            backgroundColor: 'rgba(231, 76, 60, 1)',
                            pointRadius: 8
                        },
                        {
                            label: 'Bayesian Range',
                            data: [
                                {
                                    x: bayesianRiskRange[0],
                                    y: bayesianReturnRange[0]
                                },
                                {
                                    x: bayesianRiskRange[1],
                                    y: bayesianReturnRange[0]
                                },
                                {
                                    x: bayesianRiskRange[1],
                                    y: bayesianReturnRange[1]
                                },
                                {
                                    x: bayesianRiskRange[0],
                                    y: bayesianReturnRange[1]
                                }
                            ],
                            backgroundColor: 'rgba(52, 152, 219, 0.2)',
                            borderColor: 'rgba(52, 152, 219, 0.8)',
                            borderWidth: 2,
                            pointRadius: 0,
                            showLine: true,
                            fill: true
                        },
                        {
                            label: 'Traditional Range',
                            data: [
                                {
                                    x: traditionalRiskRange[0],
                                    y: traditionalReturnRange[0]
                                },
                                {
                                    x: traditionalRiskRange[1],
                                    y: traditionalReturnRange[0]
                                },
                                {
                                    x: traditionalRiskRange[1],
                                    y: traditionalReturnRange[1]
                                },
                                {
                                    x: traditionalRiskRange[0],
                                    y: traditionalReturnRange[1]
                                }
                            ],
                            backgroundColor: 'rgba(231, 76, 60, 0.2)',
                            borderColor: 'rgba(231, 76, 60, 0.8)',
                            borderWidth: 2,
                            pointRadius: 0,
                            showLine: true,
                            fill: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Stability Analysis - Parameter Sensitivity',
                            font: {
                                size: 16
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const dataset = context.dataset.label;
                                    if (dataset.includes('Range')) return dataset;
                                    
                                    const risk = context.parsed.x.toFixed(2) + '%';
                                    const ret = context.parsed.y.toFixed(2) + '%';
                                    return `${dataset}: Risk ${risk}, Return ${ret}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Portfolio Risk (Volatility)'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Expected Return'
                            },
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1) + '%';
                                }
                            }
                        }
                    }
                }
            });
            
            // Show comparison section
            portfolioComparison.style.display = 'block';
        }
        
        // Initial setup - Generate 3 assets to start
        generateInputsBtn.click();
    </script>
</body>
</html>